diff --git a/Adafruit_GFX.cpp b/Adafruit_GFX.cpp
old mode 100755
new mode 100644
index 8a31207..3fb385b
--- a/Adafruit_GFX.cpp
+++ b/Adafruit_GFX.cpp
@@ -86,18 +86,147 @@ inline uint8_t *pgm_read_bitmap_ptr(const GFXfont *gfxFont) {
 #endif //__AVR__
 }
 
-#ifndef min
-#define min(a, b) (((a) < (b)) ? (a) : (b))
-#endif
+/// If set, use correct CP437 charset (default is off). It's a global because
+/// being pre-CP437 is program-wide, not per-display. Either the current program
+/// is a CP437 sketch or it's not.
+static boolean _cp437 = false;
+
+template <typename T> static const T &min_(const T &a, const T &b) {
+  return a < b ? a : b;
+}
+template <typename T> static const T &max_(const T &a, const T &b) {
+  return a > b ? a : b;
+}
+
+static inline void _swap_int16_t(int16_t &a, int16_t &b) {
+  int16_t t = a;
+  a = b;
+  b = t;
+}
+
+class ClassicFont : public Adafruit_GFX::AbstractFont {
+public:
+  class Glyph : public Adafruit_GFX::AbstractFont::Glyph {
+    static const uint8_t bmp_w = 5;
+    static const uint8_t bmp_h = 8;
+
+  public:
+    uint8_t width() const override { return bmp_w; }
+    uint8_t height() const override { return bmp_h; }
+    uint8_t xAdvance() const override { return 6; }
+    int8_t xOffset() const override { return 0; }
+    int8_t yOffset() const override { return 0; }
+
+    void draw(Adafruit_GFX::GlyphDraw *ctx) const override {
+      // Clip right, left, bottom, top
+      // TODO: expose bounds from the GlyphDraw?
+      // if (x >= gfx->_width || (x + gw * size_x) <= 0 ||
+      //    y >= gfx->_height || (y + gh * size_y) <= 0)
+      //  return;
+
+      for (int8_t i = 0; i < bmp_w; ++i) {
+        uint8_t vline =
+            i < xAdvance() ? (uint8_t)pgm_read_byte(&font[ch * bmp_w + i]) : 0;
+        for (int8_t j = 0; j < bmp_h; ++j, vline >>= 1)
+          ctx->setPixel(i, j, vline & 1);
+      }
+    }
+    uint8_t ch;
+  };
+
+  uint8_t yAdvance() const override { return 8; }
+  uint8_t yAdjustment() const override { return 6; }
+
+  Glyph *getGlyph(uint16_t ch) const override {
+    if (!_cp437 && ch >= 176)
+      ++ch; // Handle 'classic' charset behavior
+    if (ch >= 256)
+      return nullptr;
+    _active.ch = ch;
+    return &_active;
+  }
+
+  mutable Glyph _active;
+};
+
+class GFXfontAdapter : public Adafruit_GFX::AbstractFont {
+public:
+  class Glyph : public Adafruit_GFX::AbstractFont::Glyph {
+  public:
+    uint8_t width() const override { return pgm_read_byte(&glyph->width); }
+    uint8_t height() const override { return pgm_read_byte(&glyph->height); }
+    uint8_t xAdvance() const override {
+      return pgm_read_byte(&glyph->xAdvance);
+    }
+    int8_t xOffset() const override { return pgm_read_byte(&glyph->xOffset); }
+    int8_t yOffset() const override { return pgm_read_byte(&glyph->yOffset); }
+
+    void draw(Adafruit_GFX::GlyphDraw *ctx) const override {
+      uint16_t bo = 0;
+      uint8_t w = pgm_read_byte(&glyph->width);
+      uint8_t h = pgm_read_byte(&glyph->height);
+      int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset);
+      int16_t yo = (int8_t)pgm_read_byte(&glyph->yOffset);
+      uint8_t bits = 0;
+      uint8_t bit = 0;
+
+      // Todo: Add character clipping here
+
+      // NOTE: THERE IS NO 'BACKGROUND' COLOR OPTION ON CUSTOM FONTS.
+      // THIS IS ON PURPOSE AND BY DESIGN.  The background color feature
+      // has typically been used with the 'classic' font to overwrite old
+      // screen contents with new data.  This ONLY works because the
+      // characters are a uniform size; it's not a sensible thing to do with
+      // proportionally-spaced fonts with glyphs of varying sizes (and that
+      // may overlap).  To replace previously-drawn text when using a custom
+      // font, use the getTextBounds() function to determine the smallest
+      // rectangle encompassing a string, erase the area with fillRect(),
+      // then draw new text.  This WILL infortunately 'blink' the text, but
+      // is unavoidable.  Drawing 'background' pixels will NOT fix this,
+      // only creates a new set of problems.  Have an idea to work around
+      // this (a canvas object type for MCUs that can afford the RAM and
+      // displays supporting setAddrWindow() and pushColors()), but haven't
+      // implemented this yet.
+
+      for (int16_t yg = 0; yg < h; ++yg) {
+        for (int16_t xg = 0; xg < w; ++xg) {
+          if (!(bit++ & 7))
+            bits = pgm_read_byte(&bitmap[bo++]);
+          if (bits & 0x80) {
+            ctx->setPixel(xo + xg, yo + yg, true);
+          }
+          bits <<= 1;
+        }
+      }
+    }
 
-#ifndef _swap_int16_t
-#define _swap_int16_t(a, b)                                                    \
-  {                                                                            \
-    int16_t t = a;                                                             \
-    a = b;                                                                     \
-    b = t;                                                                     \
+    GFXglyph *glyph;
+    uint8_t *bitmap;
+  };
+
+  explicit GFXfontAdapter(const GFXfont *f) : gfxFont(f) {}
+
+  uint8_t yAdvance() const override {
+    return pgm_read_byte(&gfxFont->yAdvance);
   }
-#endif
+
+  Glyph *getGlyph(uint16_t ch) const override {
+    uint16_t first = pgm_read_word(&gfxFont->first);
+    uint16_t last = pgm_read_word(&gfxFont->last);
+    if (ch < first || ch > last)
+      return nullptr;
+    activeGlyph.glyph = pgm_read_glyph_ptr(gfxFont, ch - first);
+    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);
+    uint16_t bo = pgm_read_word(&activeGlyph.glyph->bitmapOffset);
+    activeGlyph.bitmap = bitmap + bo;
+    return &activeGlyph;
+  }
+
+  const GFXfont *gfxFont;
+  mutable Glyph activeGlyph;
+};
+
+void Adafruit_GFX::cp437(boolean x) { _cp437 = x; }
 
 /**************************************************************************/
 /*!
@@ -107,17 +236,10 @@ inline uint8_t *pgm_read_bitmap_ptr(const GFXfont *gfxFont) {
    @param    h   Display height, in pixels
 */
 /**************************************************************************/
-Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
-  _width = WIDTH;
-  _height = HEIGHT;
-  rotation = 0;
-  cursor_y = cursor_x = 0;
-  textsize_x = textsize_y = 1;
-  textcolor = textbgcolor = 0xFFFF;
-  wrap = true;
-  _cp437 = false;
-  gfxFont = NULL;
-}
+Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h)
+    : WIDTH(w), HEIGHT(h), font_(new ClassicFont()) {}
+
+Adafruit_GFX::~Adafruit_GFX() { delete font_; }
 
 /**************************************************************************/
 /*!
@@ -1134,105 +1256,46 @@ void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
 void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
                             uint16_t color, uint16_t bg, uint8_t size_x,
                             uint8_t size_y) {
+  // Get a glyph.
+  // Make a draw context.
+  // Tell the glyph to draw itself on the context.
+  AbstractFont::Glyph *glyph = font_->getGlyph(c);
+  if (!glyph)
+    return;
 
-  if (!gfxFont) { // 'Classic' built-in font
-
-    if ((x >= _width) ||              // Clip right
-        (y >= _height) ||             // Clip bottom
-        ((x + 6 * size_x - 1) < 0) || // Clip left
-        ((y + 8 * size_y - 1) < 0))   // Clip top
-      return;
-
-    if (!_cp437 && (c >= 176))
-      c++; // Handle 'classic' charset behavior
-
-    startWrite();
-    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
-      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
-      for (int8_t j = 0; j < 8; j++, line >>= 1) {
-        if (line & 1) {
-          if (size_x == 1 && size_y == 1)
-            writePixel(x + i, y + j, color);
-          else
-            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
-                          color);
-        } else if (bg != color) {
-          if (size_x == 1 && size_y == 1)
-            writePixel(x + i, y + j, bg);
-          else
-            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
-        }
-      }
-    }
-    if (bg != color) { // If opaque, draw vertical line for last column
-      if (size_x == 1 && size_y == 1)
-        writeFastVLine(x + 5, y, 8, bg);
-      else
-        writeFillRect(x + 5 * size_x, y, size_x, 8 * size_y, bg);
-    }
-    endWrite();
-
-  } else { // Custom font
-
-    // Character is assumed previously filtered by write() to eliminate
-    // newlines, returns, non-printable characters, etc.  Calling
-    // drawChar() directly with 'bad' characters of font may cause mayhem!
-
-    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
-    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
-    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);
-
-    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
-    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
-    int8_t xo = pgm_read_byte(&glyph->xOffset),
-           yo = pgm_read_byte(&glyph->yOffset);
-    uint8_t xx, yy, bits = 0, bit = 0;
-    int16_t xo16 = 0, yo16 = 0;
-
-    if (size_x > 1 || size_y > 1) {
-      xo16 = xo;
-      yo16 = yo;
-    }
-
-    // Todo: Add character clipping here
-
-    // NOTE: THERE IS NO 'BACKGROUND' COLOR OPTION ON CUSTOM FONTS.
-    // THIS IS ON PURPOSE AND BY DESIGN.  The background color feature
-    // has typically been used with the 'classic' font to overwrite old
-    // screen contents with new data.  This ONLY works because the
-    // characters are a uniform size; it's not a sensible thing to do with
-    // proportionally-spaced fonts with glyphs of varying sizes (and that
-    // may overlap).  To replace previously-drawn text when using a custom
-    // font, use the getTextBounds() function to determine the smallest
-    // rectangle encompassing a string, erase the area with fillRect(),
-    // then draw new text.  This WILL infortunately 'blink' the text, but
-    // is unavoidable.  Drawing 'background' pixels will NOT fix this,
-    // only creates a new set of problems.  Have an idea to work around
-    // this (a canvas object type for MCUs that can afford the RAM and
-    // displays supporting setAddrWindow() and pushColors()), but haven't
-    // implemented this yet.
-
-    startWrite();
-    for (yy = 0; yy < h; yy++) {
-      for (xx = 0; xx < w; xx++) {
-        if (!(bit++ & 7)) {
-          bits = pgm_read_byte(&bitmap[bo++]);
-        }
-        if (bits & 0x80) {
-          if (size_x == 1 && size_y == 1) {
-            writePixel(x + xo + xx, y + yo + yy, color);
-          } else {
-            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
-                          size_x, size_y, color);
-          }
-        }
-        bits <<= 1;
+  // Takes raw glyph pixel setting commands and applies scaling, coloring, and
+  // coordinate translation.
+  class Draw : public GlyphDraw {
+  public:
+    Draw(Adafruit_GFX *gfx, int16_t x0, int16_t y0, uint16_t fg, uint16_t bg,
+         uint8_t sx, uint8_t sy)
+        : gfx(gfx), x0(x0), y0(y0), fg(fg), bg(bg), sx(sx), sy(sy) {}
+
+    void setPixel(int16_t x, int16_t y, bool set) const override {
+      if (!set && fg == bg)
+        return; // Drawing a transparent background. Do nothing.
+      uint16_t color = set ? fg : bg;
+      if (sx == 1 && sy == 1) {
+        gfx->writePixel(x0 + x, y0 + y, color);
+      } else {
+        gfx->fillRect(x0 + x * sx, y0 + y * sy, sx, sy, color);
       }
     }
-    endWrite();
 
-  } // End classic vs custom font
+    Adafruit_GFX *gfx;
+    int16_t x0;
+    int16_t y0;
+    uint16_t fg;
+    uint16_t bg;
+    uint8_t sx;
+    uint8_t sy;
+  };
+  Draw draw(this, x, y, color, bg, size_x, size_y);
+  startWrite();
+  glyph->draw(&draw);
+  endWrite();
 }
+
 /**************************************************************************/
 /*!
     @brief  Print one byte/character of data, used to support print()
@@ -1240,48 +1303,29 @@ void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
 */
 /**************************************************************************/
 size_t Adafruit_GFX::write(uint8_t c) {
-  if (!gfxFont) { // 'Classic' built-in font
-
-    if (c == '\n') {              // Newline?
-      cursor_x = 0;               // Reset x to zero,
-      cursor_y += textsize_y * 8; // advance y one line
-    } else if (c != '\r') {       // Ignore carriage returns
-      if (wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
-        cursor_x = 0;                                       // Reset x to zero,
-        cursor_y += textsize_y * 8; // advance y one line
-      }
-      drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
-               textsize_y);
-      cursor_x += textsize_x * 6; // Advance x one char
-    }
+  if (c == '\n') {
+    cursor_x = 0;
+    cursor_y += textsize_y * font_->yAdvance();
+    return 1;
+  }
+  if (c == '\r') { // Ignore carriage returns
+    return 1;
+  }
 
-  } else { // Custom font
-
-    if (c == '\n') {
-      cursor_x = 0;
-      cursor_y +=
-          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
-    } else if (c != '\r') {
-      uint8_t first = pgm_read_byte(&gfxFont->first);
-      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
-        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
-        uint8_t w = pgm_read_byte(&glyph->width),
-                h = pgm_read_byte(&glyph->height);
-        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?
-          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
-          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
-            cursor_x = 0;
-            cursor_y += (int16_t)textsize_y *
-                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
-          }
-          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
-                   textsize_y);
-        }
-        cursor_x +=
-            (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
-      }
-    }
+  AbstractFont::Glyph *g = font_->getGlyph(c);
+  if (!g) {
+    return 1;
+  }
+
+  // Check the rightmost edge of the character against our _width
+  if (wrap && (cursor_x + textsize_x * (g->xOffset() + g->width())) > _width) {
+    cursor_x = 0;
+    cursor_y += textsize_y * font_->yAdvance();
   }
+
+  drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
+           textsize_y);
+  cursor_x += textsize_x * g->xAdvance(); // Advance x one char
   return 1;
 }
 
@@ -1336,18 +1380,14 @@ void Adafruit_GFX::setRotation(uint8_t x) {
 */
 /**************************************************************************/
 void Adafruit_GFX::setFont(const GFXfont *f) {
-  if (f) {          // Font struct pointer passed in?
-    if (!gfxFont) { // And no current font struct?
-      // Switching from classic to new font behavior.
-      // Move cursor pos down 6 pixels so it's on baseline.
-      cursor_y += 6;
-    }
-  } else if (gfxFont) { // NULL passed.  Current font struct defined?
-    // Switching from new to classic font behavior.
-    // Move cursor pos up 6 pixels so it's at top-left of char.
-    cursor_y -= 6;
-  }
-  gfxFont = (GFXfont *)f;
+  setAbstractFont(f ? new GFXfontAdapter(f) : nullptr);
+}
+
+void Adafruit_GFX::setAbstractFont(const AbstractFont *f) {
+  cursor_y += font_->yAdjustment();
+  delete font_;
+  font_ = f ? f : new ClassicFont();
+  cursor_y -= font_->yAdjustment();
 }
 
 /**************************************************************************/
@@ -1366,65 +1406,37 @@ void Adafruit_GFX::setFont(const GFXfont *f) {
 /**************************************************************************/
 void Adafruit_GFX::charBounds(char c, int16_t *x, int16_t *y, int16_t *minx,
                               int16_t *miny, int16_t *maxx, int16_t *maxy) {
+  if (c == '\n') {
+    *x = 0;
+    *y += textsize_y * font_->yAdvance();
+  }
+  if (c == '\r') {
+    // ignored
+  }
 
-  if (gfxFont) {
-
-    if (c == '\n') { // Newline?
-      *x = 0;        // Reset x to zero, advance y by one line
-      *y += textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
-    } else if (c != '\r') { // Not a carriage return; is normal char
-      uint8_t first = pgm_read_byte(&gfxFont->first),
-              last = pgm_read_byte(&gfxFont->last);
-      if ((c >= first) && (c <= last)) { // Char present in this font?
-        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
-        uint8_t gw = pgm_read_byte(&glyph->width),
-                gh = pgm_read_byte(&glyph->height),
-                xa = pgm_read_byte(&glyph->xAdvance);
-        int8_t xo = pgm_read_byte(&glyph->xOffset),
-               yo = pgm_read_byte(&glyph->yOffset);
-        if (wrap && ((*x + (((int16_t)xo + gw) * textsize_x)) > _width)) {
-          *x = 0; // Reset x to zero, advance y by one line
-          *y += textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
-        }
-        int16_t tsx = (int16_t)textsize_x, tsy = (int16_t)textsize_y,
-                x1 = *x + xo * tsx, y1 = *y + yo * tsy, x2 = x1 + gw * tsx - 1,
-                y2 = y1 + gh * tsy - 1;
-        if (x1 < *minx)
-          *minx = x1;
-        if (y1 < *miny)
-          *miny = y1;
-        if (x2 > *maxx)
-          *maxx = x2;
-        if (y2 > *maxy)
-          *maxy = y2;
-        *x += xa * tsx;
-      }
-    }
-
-  } else { // Default font
+  const AbstractFont::Glyph *g = font_->getGlyph(c);
+  if (!g)
+    return;
 
-    if (c == '\n') {        // Newline?
-      *x = 0;               // Reset x to zero,
-      *y += textsize_y * 8; // advance y one line
-      // min/max x/y unchaged -- that waits for next 'normal' character
-    } else if (c != '\r') { // Normal char; ignore carriage returns
-      if (wrap && ((*x + textsize_x * 6) > _width)) { // Off right?
-        *x = 0;                                       // Reset x to zero,
-        *y += textsize_y * 8;                         // advance y one line
-      }
-      int x2 = *x + textsize_x * 6 - 1, // Lower-right pixel of char
-          y2 = *y + textsize_y * 8 - 1;
-      if (x2 > *maxx)
-        *maxx = x2; // Track max x, y
-      if (y2 > *maxy)
-        *maxy = y2;
-      if (*x < *minx)
-        *minx = *x; // Track min x, y
-      if (*y < *miny)
-        *miny = *y;
-      *x += textsize_x * 6; // Advance x one char
-    }
+  uint8_t gw = g->width();
+  uint8_t gh = g->height();
+  uint8_t xa = g->xAdvance();
+  int8_t xo = g->xOffset();
+  int8_t yo = g->yOffset();
+  if (wrap && ((*x + textsize_x * (xo + gw)) > _width)) {
+    *x = 0;
+    *y += textsize_y * font_->yAdvance();
   }
+  int16_t x1 = *x + textsize_x * xo;
+  int16_t y1 = *y + textsize_y * yo;
+  int16_t x2 = x1 + textsize_x * gw - 1;
+  int16_t y2 = y1 + textsize_y * gh - 1;
+
+  *minx = min_(*minx, x1);
+  *miny = min_(*miny, y1);
+  *maxx = max_(*maxx, x2);
+  *maxy = max_(*maxy, y2);
+  *x += textsize_x * xa;
 }
 
 /**************************************************************************/
@@ -1673,7 +1685,7 @@ void Adafruit_GFX_Button::drawButton(boolean inverted) {
     text = _fillcolor;
   }
 
-  uint8_t r = min(_w, _h) / 4; // Corner radius
+  uint8_t r = min_(_w, _h) / 4; // Corner radius
   _gfx->fillRoundRect(_x1, _y1, _w, _h, r, fill);
   _gfx->drawRoundRect(_x1, _y1, _w, _h, r, outline);
 
diff --git a/Adafruit_GFX.h b/Adafruit_GFX.h
index 1bbac47..64fd77a 100644
--- a/Adafruit_GFX.h
+++ b/Adafruit_GFX.h
@@ -13,9 +13,43 @@
 /// minimum you can subclass and provide drawPixel(). At a maximum you can do a
 /// ton of overriding to optimize. Used for any/all Adafruit displays!
 class Adafruit_GFX : public Print {
-
 public:
+  class GlyphDraw {
+  public:
+    // set or clear one logical pixel.
+    virtual void setPixel(int16_t x, int16_t y, bool set) const = 0;
+  };
+
+  class AbstractFont {
+  public:
+    class Glyph {
+    public:
+      virtual uint8_t width() const = 0;
+      virtual uint8_t height() const = 0;
+      virtual uint8_t xAdvance() const = 0;
+      virtual int8_t xOffset() const = 0;
+      virtual int8_t yOffset() const = 0;
+      // Glyphs just known how to draw in an implied color, at an implied
+      // scale, at an implied origin. The GlyphDraw takes care of all
+      // necessary transformations into the coordinates of the GFX.
+      virtual void draw(GlyphDraw *ctx) const = 0;
+    };
+
+    virtual ~AbstractFont() = default;
+    virtual uint8_t yAdvance() const = 0;
+    virtual Glyph *getGlyph(uint16_t ch) const = 0;
+
+    // The amount removed from cursorY when this font is installed,
+    // and added to cursorY when this font is uninstalled.
+    // Only ClassicFont does anything interesting here.
+    // ClassicFont interprets cursor as topleft corner of glyph.
+    // So when it is replaced, the cursor moves down by 6pixels so
+    // the baseline of subsequent gfx->print statements will match.
+    virtual uint8_t yAdjustment() const { return 0; }
+  };
+
   Adafruit_GFX(int16_t w, int16_t h); // Constructor
+  virtual ~Adafruit_GFX();
 
   /**********************************************************************/
   /*!
@@ -116,8 +150,12 @@ public:
                      int16_t *y1, uint16_t *w, uint16_t *h);
   void setTextSize(uint8_t s);
   void setTextSize(uint8_t sx, uint8_t sy);
+
   void setFont(const GFXfont *f = NULL);
 
+  /* Takes ownership of abstract font 'f'. */
+  void setAbstractFont(const AbstractFont *f);
+
   /**********************************************************************/
   /*!
     @brief  Set text cursor location
@@ -164,18 +202,20 @@ public:
   /**********************************************************************/
   /*!
     @brief  Enable (or disable) Code Page 437-compatible charset.
-            There was an error in glcdfont.c for the longest time -- one
-            character (#176, the 'light shade' block) was missing -- this
-            threw off the index of every character that followed it.
-            But a TON of code has been written with the erroneous
-            character indices. By default, the library uses the original
-            'wrong' behavior and old sketches will still work. Pass
-            'true' to this function to use correct CP437 character values
-            in your code.
+
+    There was an error in glcdfont.c for the longest time -- one
+    character (#176, the 'light shade' block) was missing -- this
+    threw off the index of every character that followed it.
+    But a TON of code has been written with the erroneous
+    character indices. By default, the library uses the original
+    'wrong' behavior and old sketches will still work. Pass
+    'true' to this function to use correct CP437 character values
+    in your code.
+
     @param  x  true = enable (new behavior), false = disable (old behavior)
   */
   /**********************************************************************/
-  void cp437(boolean x = true) { _cp437 = x; }
+  static void cp437(boolean x = true);
 
   using Print::write;
 #if ARDUINO >= 100
@@ -229,20 +269,23 @@ public:
 protected:
   void charBounds(char c, int16_t *x, int16_t *y, int16_t *minx, int16_t *miny,
                   int16_t *maxx, int16_t *maxy);
-  int16_t WIDTH;        ///< This is the 'raw' display width - never changes
-  int16_t HEIGHT;       ///< This is the 'raw' display height - never changes
-  int16_t _width;       ///< Display width as modified by current rotation
-  int16_t _height;      ///< Display height as modified by current rotation
-  int16_t cursor_x;     ///< x location to start print()ing text
-  int16_t cursor_y;     ///< y location to start print()ing text
-  uint16_t textcolor;   ///< 16-bit background color for print()
-  uint16_t textbgcolor; ///< 16-bit text color for print()
-  uint8_t textsize_x;   ///< Desired magnification in X-axis of text to print()
-  uint8_t textsize_y;   ///< Desired magnification in Y-axis of text to print()
-  uint8_t rotation;     ///< Display rotation (0 thru 3)
-  boolean wrap;         ///< If set, 'wrap' text at right edge of display
-  boolean _cp437;       ///< If set, use correct CP437 charset (default is off)
-  GFXfont *gfxFont;     ///< Pointer to special font
+  int16_t WIDTH;            ///< 'raw' display width - never changes
+  int16_t HEIGHT;           ///< 'raw' display height - never changes
+  int16_t _width = WIDTH;   ///< Display width as modified by current rotation
+  int16_t _height = HEIGHT; ///< Display height as modified by current rotation
+
+  int16_t cursor_x = 0;          ///< x location to start print()ing text
+  int16_t cursor_y = 0;          ///< y location to start print()ing text
+  uint16_t textcolor = 0xFFFF;   ///< 16-bit background color for print()
+  uint16_t textbgcolor = 0xFFFF; ///< 16-bit text color for print()
+  uint8_t textsize_x = 1;        ///< horizontal text scaling for print()
+  uint8_t textsize_y = 1;        ///< vertical text scaling for print()
+
+  uint8_t rotation = 0; ///< Display rotation (0 thru 3)
+  boolean wrap = true;  ///< Wrap text at right edge of display?
+
+private:
+  const AbstractFont *font_; // owned
 };
 
 /// A simple drawn button UI element
@@ -362,4 +405,4 @@ private:
   uint16_t *buffer;
 };
 
-#endif // _ADAFRUIT_GFX_H
+#endif // _ADAFRUIT_GFX_H
\ No newline at end of file
diff --git a/Adafruit_MonoOLED.cpp b/Adafruit_MonoOLED.cpp
index 34ddf17..1f45af7 100644
--- a/Adafruit_MonoOLED.cpp
+++ b/Adafruit_MonoOLED.cpp
@@ -60,9 +60,8 @@
 Adafruit_MonoOLED::Adafruit_MonoOLED(uint16_t w, uint16_t h, TwoWire *twi,
                                      int8_t rst_pin, uint32_t clkDuring,
                                      uint32_t clkAfter)
-    : Adafruit_GFX(w, h), buffer(NULL), dcPin(-1), csPin(-1), rstPin(rst_pin),
-      i2c_preclk(clkDuring), i2c_postclk(clkAfter) {
-  i2c_dev = NULL;
+    : Adafruit_GFX(w, h), i2c_preclk(clkDuring), i2c_postclk(clkAfter),
+      dcPin(-1), csPin(-1), rstPin(rst_pin) {
   _theWire = twi;
 }
 
diff --git a/glcdfont.c b/glcdfont.c
index 535da3a..c575709 100644
--- a/glcdfont.c
+++ b/glcdfont.c
@@ -1,8 +1,7 @@
 // This is the 'classic' fixed-space bitmap font for Adafruit_GFX since 1.0.
 // See gfxfont.h for newer custom bitmap font info.
 
-#ifndef FONT5X7_H
-#define FONT5X7_H
+#include <stdint.h>
 
 #ifdef __AVR__
 #include <avr/io.h>
@@ -17,127 +16,262 @@
 #define PROGMEM
 #endif
 
-// Standard ASCII 5x7 font
-
-static const unsigned char font[] PROGMEM = {
-    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,
-    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,
-    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
-    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,
-    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,
-    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,
-    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,
-    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,
-    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,
-    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,
-    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,
-    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,
-    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,
-    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,
-    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,
-    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,
-    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,
-    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,
-    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,
-    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,
-    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,
-    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,
-    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,
-    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,
-    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,
-    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,
-    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,
-    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,
-    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,
-    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,
-    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,
-    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,
-    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,
-    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,
-    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,
-    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,
-    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,
-    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
-    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,
-    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,
-    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,
-    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,
-    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,
-    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,
-    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,
-    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,
-    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,
-    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,
-    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,
-    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,
-    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,
-    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,
-    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,
-    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,
-    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,
+// Standard ASCII 6 x 8 font (5x8 bitmaps)
+extern const uint8_t font[] PROGMEM = {
+    0x00, 0x00, 0x00, 0x00, 0x00, //
+    0x3E, 0x5B, 0x4F, 0x5B, 0x3E, //
+    0x3E, 0x6B, 0x4F, 0x6B, 0x3E, //
+    0x1C, 0x3E, 0x7C, 0x3E, 0x1C, //
+    0x18, 0x3C, 0x7E, 0x3C, 0x18, //
+    0x1C, 0x57, 0x7D, 0x57, 0x1C, //
+    0x1C, 0x5E, 0x7F, 0x5E, 0x1C, //
+    0x00, 0x18, 0x3C, 0x18, 0x00, //
+    0xFF, 0xE7, 0xC3, 0xE7, 0xFF, //
+    0x00, 0x18, 0x24, 0x18, 0x00, //
+    0xFF, 0xE7, 0xDB, 0xE7, 0xFF, //
+    0x30, 0x48, 0x3A, 0x06, 0x0E, //
+    0x26, 0x29, 0x79, 0x29, 0x26, //
+    0x40, 0x7F, 0x05, 0x05, 0x07, //
+    0x40, 0x7F, 0x05, 0x25, 0x3F, //
+    0x5A, 0x3C, 0xE7, 0x3C, 0x5A, //
+    0x7F, 0x3E, 0x1C, 0x1C, 0x08, //
+    0x08, 0x1C, 0x1C, 0x3E, 0x7F, //
+    0x14, 0x22, 0x7F, 0x22, 0x14, //
+    0x5F, 0x5F, 0x00, 0x5F, 0x5F, //
+    0x06, 0x09, 0x7F, 0x01, 0x7F, //
+    0x00, 0x66, 0x89, 0x95, 0x6A, //
+    0x60, 0x60, 0x60, 0x60, 0x60, //
+    0x94, 0xA2, 0xFF, 0xA2, 0x94, //
+    0x08, 0x04, 0x7E, 0x04, 0x08, //
+    0x10, 0x20, 0x7E, 0x20, 0x10, //
+    0x08, 0x08, 0x2A, 0x1C, 0x08, //
+    0x08, 0x1C, 0x2A, 0x08, 0x08, //
+    0x1E, 0x10, 0x10, 0x10, 0x10, //
+    0x0C, 0x1E, 0x0C, 0x1E, 0x0C, //
+    0x30, 0x38, 0x3E, 0x38, 0x30, //
+    0x06, 0x0E, 0x3E, 0x0E, 0x06, //
+    0x00, 0x00, 0x00, 0x00, 0x00, //
+    0x00, 0x00, 0x5F, 0x00, 0x00, //
+    0x00, 0x07, 0x00, 0x07, 0x00, //
+    0x14, 0x7F, 0x14, 0x7F, 0x14, //
+    0x24, 0x2A, 0x7F, 0x2A, 0x12, //
+    0x23, 0x13, 0x08, 0x64, 0x62, //
+    0x36, 0x49, 0x56, 0x20, 0x50, //
+    0x00, 0x08, 0x07, 0x03, 0x00, //
+    0x00, 0x1C, 0x22, 0x41, 0x00, //
+    0x00, 0x41, 0x22, 0x1C, 0x00, //
+    0x2A, 0x1C, 0x7F, 0x1C, 0x2A, //
+    0x08, 0x08, 0x3E, 0x08, 0x08, //
+    0x00, 0x80, 0x70, 0x30, 0x00, //
+    0x08, 0x08, 0x08, 0x08, 0x08, //
+    0x00, 0x00, 0x60, 0x60, 0x00, //
+    0x20, 0x10, 0x08, 0x04, 0x02, //
+    0x3E, 0x51, 0x49, 0x45, 0x3E, //
+    0x00, 0x42, 0x7F, 0x40, 0x00, //
+    0x72, 0x49, 0x49, 0x49, 0x46, //
+    0x21, 0x41, 0x49, 0x4D, 0x33, //
+    0x18, 0x14, 0x12, 0x7F, 0x10, //
+    0x27, 0x45, 0x45, 0x45, 0x39, //
+    0x3C, 0x4A, 0x49, 0x49, 0x31, //
+    0x41, 0x21, 0x11, 0x09, 0x07, //
+    0x36, 0x49, 0x49, 0x49, 0x36, //
+    0x46, 0x49, 0x49, 0x29, 0x1E, //
+    0x00, 0x00, 0x14, 0x00, 0x00, //
+    0x00, 0x40, 0x34, 0x00, 0x00, //
+    0x00, 0x08, 0x14, 0x22, 0x41, //
+    0x14, 0x14, 0x14, 0x14, 0x14, //
+    0x00, 0x41, 0x22, 0x14, 0x08, //
+    0x02, 0x01, 0x59, 0x09, 0x06, //
+    0x3E, 0x41, 0x5D, 0x59, 0x4E, //
+    0x7C, 0x12, 0x11, 0x12, 0x7C, //
+    0x7F, 0x49, 0x49, 0x49, 0x36, //
+    0x3E, 0x41, 0x41, 0x41, 0x22, //
+    0x7F, 0x41, 0x41, 0x41, 0x3E, //
+    0x7F, 0x49, 0x49, 0x49, 0x41, //
+    0x7F, 0x09, 0x09, 0x09, 0x01, //
+    0x3E, 0x41, 0x41, 0x51, 0x73, //
+    0x7F, 0x08, 0x08, 0x08, 0x7F, //
+    0x00, 0x41, 0x7F, 0x41, 0x00, //
+    0x20, 0x40, 0x41, 0x3F, 0x01, //
+    0x7F, 0x08, 0x14, 0x22, 0x41, //
+    0x7F, 0x40, 0x40, 0x40, 0x40, //
+    0x7F, 0x02, 0x1C, 0x02, 0x7F, //
+    0x7F, 0x04, 0x08, 0x10, 0x7F, //
+    0x3E, 0x41, 0x41, 0x41, 0x3E, //
+    0x7F, 0x09, 0x09, 0x09, 0x06, //
+    0x3E, 0x41, 0x51, 0x21, 0x5E, //
+    0x7F, 0x09, 0x19, 0x29, 0x46, //
+    0x26, 0x49, 0x49, 0x49, 0x32, //
+    0x03, 0x01, 0x7F, 0x01, 0x03, //
+    0x3F, 0x40, 0x40, 0x40, 0x3F, //
+    0x1F, 0x20, 0x40, 0x20, 0x1F, //
+    0x3F, 0x40, 0x38, 0x40, 0x3F, //
+    0x63, 0x14, 0x08, 0x14, 0x63, //
+    0x03, 0x04, 0x78, 0x04, 0x03, //
+    0x61, 0x59, 0x49, 0x4D, 0x43, //
+    0x00, 0x7F, 0x41, 0x41, 0x41, //
+    0x02, 0x04, 0x08, 0x10, 0x20, //
+    0x00, 0x41, 0x41, 0x41, 0x7F, //
+    0x04, 0x02, 0x01, 0x02, 0x04, //
+    0x40, 0x40, 0x40, 0x40, 0x40, //
+    0x00, 0x03, 0x07, 0x08, 0x00, //
+    0x20, 0x54, 0x54, 0x78, 0x40, //
+    0x7F, 0x28, 0x44, 0x44, 0x38, //
+    0x38, 0x44, 0x44, 0x44, 0x28, //
+    0x38, 0x44, 0x44, 0x28, 0x7F, //
+    0x38, 0x54, 0x54, 0x54, 0x18, //
+    0x00, 0x08, 0x7E, 0x09, 0x02, //
+    0x18, 0xA4, 0xA4, 0x9C, 0x78, //
+    0x7F, 0x08, 0x04, 0x04, 0x78, //
+    0x00, 0x44, 0x7D, 0x40, 0x00, //
+    0x20, 0x40, 0x40, 0x3D, 0x00, //
+    0x7F, 0x10, 0x28, 0x44, 0x00, //
+    0x00, 0x41, 0x7F, 0x40, 0x00, //
+    0x7C, 0x04, 0x78, 0x04, 0x78, //
+    0x7C, 0x08, 0x04, 0x04, 0x78, //
+    0x38, 0x44, 0x44, 0x44, 0x38, //
+    0xFC, 0x18, 0x24, 0x24, 0x18, //
+    0x18, 0x24, 0x24, 0x18, 0xFC, //
+    0x7C, 0x08, 0x04, 0x04, 0x08, //
+    0x48, 0x54, 0x54, 0x54, 0x24, //
+    0x04, 0x04, 0x3F, 0x44, 0x24, //
+    0x3C, 0x40, 0x40, 0x20, 0x7C, //
+    0x1C, 0x20, 0x40, 0x20, 0x1C, //
+    0x3C, 0x40, 0x30, 0x40, 0x3C, //
+    0x44, 0x28, 0x10, 0x28, 0x44, //
+    0x4C, 0x90, 0x90, 0x90, 0x7C, //
+    0x44, 0x64, 0x54, 0x4C, 0x44, //
+    0x00, 0x08, 0x36, 0x41, 0x00, //
+    0x00, 0x00, 0x77, 0x00, 0x00, //
+    0x00, 0x41, 0x36, 0x08, 0x00, //
+    0x02, 0x01, 0x02, 0x04, 0x02, //
+    0x3C, 0x26, 0x23, 0x26, 0x3C, //
+    0x1E, 0xA1, 0xA1, 0x61, 0x12, //
+    0x3A, 0x40, 0x40, 0x20, 0x7A, //
+    0x38, 0x54, 0x54, 0x55, 0x59, //
+    0x21, 0x55, 0x55, 0x79, 0x41, //
     0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
-    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,
-    0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,
-    0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
-    0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,
-    0x12, 0x7D, // A-umlaut
-    0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,
-    0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,
-    0x32, 0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
-    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,
-    0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,
-    0x3D, // O-umlaut
-    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,
-    0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,
-    0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
-    0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,
-    0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,
-    0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,
-    0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
-    0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
-    0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,
-    0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old
-                                              // code
-    0xAA, 0x55, 0xAA, 0x55, 0xAA,             // 50% block
-    0xFF, 0x55, 0xFF, 0x55, 0xFF,             // 75% block
-    0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,
-    0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,
-    0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
-    0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,
-    0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,
-    0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,
-    0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,
-    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
-    0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,
-    0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,
-    0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,
-    0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,
-    0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,
-    0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,
-    0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,
-    0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,
-    0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,
-    0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
-    0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,
-    0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
-    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,
-    0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,
-    0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,
-    0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,
-    0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,
-    0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,
-    0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,
-    0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,
-    0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,
-    0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,
-    0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,
-    0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,
-    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
-};
-
-// allow clean compilation with [-Wunused-const-variable=] and [-Wall]
-static inline void avoid_unused_const_variable_compiler_warning(void) {
-  (void)font;
-}
-
-#endif // FONT5X7_H
+    0x21, 0x55, 0x54, 0x78, 0x40, //
+    0x20, 0x54, 0x55, 0x79, 0x40, //
+    0x0C, 0x1E, 0x52, 0x72, 0x12, //
+    0x39, 0x55, 0x55, 0x55, 0x59, //
+    0x39, 0x54, 0x54, 0x54, 0x59, //
+    0x39, 0x55, 0x54, 0x54, 0x58, //
+    0x00, 0x00, 0x45, 0x7C, 0x41, //
+    0x00, 0x02, 0x45, 0x7D, 0x42, //
+    0x00, 0x01, 0x45, 0x7C, 0x40, //
+    0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut
+    0xF0, 0x28, 0x25, 0x28, 0xF0, //
+    0x7C, 0x54, 0x55, 0x45, 0x00, //
+    0x20, 0x54, 0x54, 0x7C, 0x54, //
+    0x7C, 0x0A, 0x09, 0x7F, 0x49, //
+    0x32, 0x49, 0x49, 0x49, 0x32, //
+    0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
+    0x32, 0x4A, 0x48, 0x48, 0x30, //
+    0x3A, 0x41, 0x41, 0x21, 0x7A, //
+    0x3A, 0x42, 0x40, 0x20, 0x78, //
+    0x00, 0x9D, 0xA0, 0xA0, 0x7D, //
+    0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
+    0x3D, 0x40, 0x40, 0x40, 0x3D, //
+    0x3C, 0x24, 0xFF, 0x24, 0x24, //
+    0x48, 0x7E, 0x49, 0x43, 0x66, //
+    0x2B, 0x2F, 0xFC, 0x2F, 0x2B, //
+    0xFF, 0x09, 0x29, 0xF6, 0x20, //
+    0xC0, 0x88, 0x7E, 0x09, 0x03, //
+    0x20, 0x54, 0x54, 0x79, 0x41, //
+    0x00, 0x00, 0x44, 0x7D, 0x41, //
+    0x30, 0x48, 0x48, 0x4A, 0x32, //
+    0x38, 0x40, 0x40, 0x22, 0x7A, //
+    0x00, 0x7A, 0x0A, 0x0A, 0x72, //
+    0x7D, 0x0D, 0x19, 0x31, 0x7D, //
+    0x26, 0x29, 0x29, 0x2F, 0x28, //
+    0x26, 0x29, 0x29, 0x29, 0x26, //
+    0x30, 0x48, 0x4D, 0x40, 0x20, //
+    0x38, 0x08, 0x08, 0x08, 0x08, //
+    0x08, 0x08, 0x08, 0x08, 0x38, //
+    0x2F, 0x10, 0xC8, 0xAC, 0xBA, //
+    0x2F, 0x10, 0x28, 0x34, 0xFA, //
+    0x00, 0x00, 0x7B, 0x00, 0x00, //
+    0x08, 0x14, 0x2A, 0x14, 0x22, //
+    0x22, 0x14, 0x2A, 0x14, 0x08, //
+    0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old code
+    0xAA, 0x55, 0xAA, 0x55, 0xAA, // 50% block
+    0xFF, 0x55, 0xFF, 0x55, 0xFF, // 75% block
+    0x00, 0x00, 0x00, 0xFF, 0x00, //
+    0x10, 0x10, 0x10, 0xFF, 0x00, //
+    0x14, 0x14, 0x14, 0xFF, 0x00, //
+    0x10, 0x10, 0xFF, 0x00, 0xFF, //
+    0x10, 0x10, 0xF0, 0x10, 0xF0, //
+    0x14, 0x14, 0x14, 0xFC, 0x00, //
+    0x14, 0x14, 0xF7, 0x00, 0xFF, //
+    0x00, 0x00, 0xFF, 0x00, 0xFF, //
+    0x14, 0x14, 0xF4, 0x04, 0xFC, //
+    0x14, 0x14, 0x17, 0x10, 0x1F, //
+    0x10, 0x10, 0x1F, 0x10, 0x1F, //
+    0x14, 0x14, 0x14, 0x1F, 0x00, //
+    0x10, 0x10, 0x10, 0xF0, 0x00, //
+    0x00, 0x00, 0x00, 0x1F, 0x10, //
+    0x10, 0x10, 0x10, 0x1F, 0x10, //
+    0x10, 0x10, 0x10, 0xF0, 0x10, //
+    0x00, 0x00, 0x00, 0xFF, 0x10, //
+    0x10, 0x10, 0x10, 0x10, 0x10, //
+    0x10, 0x10, 0x10, 0xFF, 0x10, //
+    0x00, 0x00, 0x00, 0xFF, 0x14, //
+    0x00, 0x00, 0xFF, 0x00, 0xFF, //
+    0x00, 0x00, 0x1F, 0x10, 0x17, //
+    0x00, 0x00, 0xFC, 0x04, 0xF4, //
+    0x14, 0x14, 0x17, 0x10, 0x17, //
+    0x14, 0x14, 0xF4, 0x04, 0xF4, //
+    0x00, 0x00, 0xFF, 0x00, 0xF7, //
+    0x14, 0x14, 0x14, 0x14, 0x14, //
+    0x14, 0x14, 0xF7, 0x00, 0xF7, //
+    0x14, 0x14, 0x14, 0x17, 0x14, //
+    0x10, 0x10, 0x1F, 0x10, 0x1F, //
+    0x14, 0x14, 0x14, 0xF4, 0x14, //
+    0x10, 0x10, 0xF0, 0x10, 0xF0, //
+    0x00, 0x00, 0x1F, 0x10, 0x1F, //
+    0x00, 0x00, 0x00, 0x1F, 0x14, //
+    0x00, 0x00, 0x00, 0xFC, 0x14, //
+    0x00, 0x00, 0xF0, 0x10, 0xF0, //
+    0x10, 0x10, 0xFF, 0x10, 0xFF, //
+    0x14, 0x14, 0x14, 0xFF, 0x14, //
+    0x10, 0x10, 0x10, 0x1F, 0x00, //
+    0x00, 0x00, 0x00, 0xF0, 0x10, //
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //
+    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, //
+    0xFF, 0xFF, 0xFF, 0x00, 0x00, //
+    0x00, 0x00, 0x00, 0xFF, 0xFF, //
+    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, //
+    0x38, 0x44, 0x44, 0x38, 0x44, //
+    0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
+    0x7E, 0x02, 0x02, 0x06, 0x06, //
+    0x02, 0x7E, 0x02, 0x7E, 0x02, //
+    0x63, 0x55, 0x49, 0x41, 0x63, //
+    0x38, 0x44, 0x44, 0x3C, 0x04, //
+    0x40, 0x7E, 0x20, 0x1E, 0x20, //
+    0x06, 0x02, 0x7E, 0x02, 0x02, //
+    0x99, 0xA5, 0xE7, 0xA5, 0x99, //
+    0x1C, 0x2A, 0x49, 0x2A, 0x1C, //
+    0x4C, 0x72, 0x01, 0x72, 0x4C, //
+    0x30, 0x4A, 0x4D, 0x4D, 0x30, //
+    0x30, 0x48, 0x78, 0x48, 0x30, //
+    0xBC, 0x62, 0x5A, 0x46, 0x3D, //
+    0x3E, 0x49, 0x49, 0x49, 0x00, //
+    0x7E, 0x01, 0x01, 0x01, 0x7E, //
+    0x2A, 0x2A, 0x2A, 0x2A, 0x2A, //
+    0x44, 0x44, 0x5F, 0x44, 0x44, //
+    0x40, 0x51, 0x4A, 0x44, 0x40, //
+    0x40, 0x44, 0x4A, 0x51, 0x40, //
+    0x00, 0x00, 0xFF, 0x01, 0x03, //
+    0xE0, 0x80, 0xFF, 0x00, 0x00, //
+    0x08, 0x08, 0x6B, 0x6B, 0x08, //
+    0x36, 0x12, 0x36, 0x24, 0x36, //
+    0x06, 0x0F, 0x09, 0x0F, 0x06, //
+    0x00, 0x00, 0x18, 0x18, 0x00, //
+    0x00, 0x00, 0x10, 0x10, 0x00, //
+    0x30, 0x40, 0xFF, 0x01, 0x01, //
+    0x00, 0x1F, 0x01, 0x01, 0x1E, //
+    0x00, 0x19, 0x1D, 0x17, 0x12, //
+    0x00, 0x3C, 0x3C, 0x3C, 0x3C, //
+    0x00, 0x00, 0x00, 0x00, 0x00  // #255 NBSP
+};
\ No newline at end of file
diff --git a/library.properties b/library.properties
index bba2e70..5daa146 100644
--- a/library.properties
+++ b/library.properties
@@ -1,5 +1,5 @@
 name=Adafruit GFX Library
-version=1.8.1
+version=1.8.1-glcdunify
 author=Adafruit
 maintainer=Adafruit <info@adafruit.com>
 sentence=Adafruit GFX graphics core library, this is the 'core' class that all our other graphics libraries derive from.
